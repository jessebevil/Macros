	|||||||||||||||||||||||||||||||||||||||||||||||||||
|Farm.mac by Chatwiththisname
|v1.20 ~ Initial release 2/15/2018
|	   ~ Ignores Update 3/15/2018
|	   ~ Now generates a quick list of named, merchants,
|		 bankers, and NPCs, as well as a permanent ignore list
|		 that you can easily copy/paste from other list per zone.
|	   ~ Now features /permignore to add things to the permanent 
|		 ignore list in FarmMobIgnored.ini [${Zone.ShortName}]
|		 Ignores=|mob1|mob2|mob3| etc. NOTE: /ignorethese and 
|		 /ignorethis is temporary and uses alert lists which reset
|		 when you leave. You can access a list of temporarily ignored
|		 mobs by typing /alert list 1
|	  ~ 3/15/2018
|	  ~ Now includes a UseEQBC & assistMe boolean in the declares sub found 
|		in the last sub of the code. UseEQBC will tell your crew to follow
|		you every time you issue a navigation command. assistMe will tell 
|		your crew to target the same mobs, and assist with killing it. 
|		This assumes you are farming lowbie crap, and thus there is no
|		required hp for engaging, it's immediate and often your group will
|		engage first because the macro runner is waiting for the navigation
|		path to finish. If you just want them to follow you for EXP or loot
|		just turn on UseEQBC, if you want them to help kill, turn on assistMe
|		WARNING: You -definitely- look like a bot with assistMe this lol.
|	  ~ Now verifies your starting zone and will end the macro if you change zones
|		now includes useCamp boolean to know if you want to /exit when you leave 
|		your starting zone. If UseEQBC is TRUE it will /exit all other toons on
|		the EQBC Server, that said, make sure that's what you want to do when using
|		this feature. 
|
|Usage: /mac Farm radius target ~~ /mac farm 500 pyrilen
|		/mac farm radius ~~ /mac farm 1000
|		
|
|Purpose: Will kill and move anything forever in a radius
|			near you. It -WILL- navigate the entire zone.
|			IE: Used in RSS I started at entrance, come back
|			an hour later and I was doing the raid mobs. 
|			
|		If you provide it a target's partial/full name it will 
|		only hunt down those creatures. But it will react to adds.
|
|		/ignorethis to ignore your current target only.
|		/ignorethese to ignore all spawns with your targets full name.
|		/permignore to permanently ignore all spawns with your targets full name. 
|
	|||||||||||||||||||||||||||||||||||||||||||||||||||
||**



**|

#bind AddToIgnore /ignorethese
#bind AddThisIgnore /ignorethis
#bind PermIgnore /permignore
|#bind showignored /showignored

Sub Main(int Param0, string Param1)
	/declare PullRange int outer ${Param0}
	/declare FarmMob string outer ${Param1}
	/declare i int local 2
	/while (${Defined[Param${i}]}) {
		/varset FarmMob ${FarmMob} ${Param${i}}
		/varcalc i ${i}+1
		/if (!${Defined[Param${i}]}) /break
	}

	/call Declares ${Param0} "${Param1}"
	/if (${Bool[${FarmMob}]}) {
		/echo Attempting to farm ${FarmMob}.
	} else {
		/echo Attacking anything I can get my grubby paws on.
	}
	/echo Usage: /farm radius mobstring, example: /farm 10000 cave_bear
	/call GenerateList
	/if (${Debugging}) /delay 2s

	/if (${UseEQBC} && !${Me.CombatState.Equal[Combat]}) {
		/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target me and stick (WaitNav).
		/bca //target id ${Me.ID}
		/delay 5
		/bca //stick 10 loose moveback uw behind
	}
	/while (${EverQuest.GameState.Equal[INGAME]} && ${Zone.ID} == ${startZone}) {
		/if (${Zone.ID} != ${startZone}) /break
		/call Farmstuff "${FarmMob}"
	}
	/if (${useLogOut} && ${Zone.ID} != ${startZone}) {
		/if (${UseEQBC}) /bca //exit
		/exit
	}
	
/return
	:OnExit
	/alias /showignored delete
	/invoke ${Macro.Undeclared}
	/setchattitle MQ2
	/end

Sub TargetShortest
	/declare PullTargetID int local 0
	/declare Shortest int local 0
	
	/if (!${Me.XTarget[1].ID}) {
		|In order if I should even loop through to see how many mobs are in range I need to get a count based on my conditions
		/declare MobsInRange int local ${SpawnCount[npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"]}
		/if (${Debugging}) /echo There were ${MobsInRange} ${FarmMob} in radius of ${PullRange} and ZRad: ${ZRadius}.
		/declare i int local 0
		/declare j int local 1
		/if (${MobsInRange}) {
			/if (${MobsInRange} > 100) {
				/if (!${Debugging}) /echo There were more than 100 mobs in range, cutting down the list.
				/varset MobsInRange 100
			}
		|** PullList[#,1] = ID of mob, PullList[#,2] = PathLength **|
		|I created an array and made it the size of the mobcount by the 2 to store each mob's ID and the length of their nav path
			/declare PullList[${MobsInRange},2] int local 0
			|I set i equal to 1 and I iterate through each mob
			/for i 1 to ${MobsInRange}
				|just in case something dies, I don't to result in NULL during my check producing results
				|I also want to ignore mobs in the ignores section.
				/if (${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].Name.NotEqual[NULL]} && !${Ini[${MobIgnore},${Zone.ShortName},Ignored].Find[${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].CleanName}|]}) {
					|/echo \atFound one. Maybe, lets see if it has a path. 
					|If there is a path and only if there is a path will I enter the following block statement. This is done to avoid adding mobs to the array that don't have a path.
					
					/if (${Navigation.PathExists[id ${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].ID}]} && ${Int[${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].Distance3D}]} <= ${Int[${Navigation.PathLength[id ${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].ID}]}]}) {
						|** Before I add them to the pull list, let me also check that they still have 100% Hps. **|
						/if (${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].PctHPs} == 100) {
							|Now that I know this mob has a Navigation path, I need to add it to the array where ${j} is incremented only if I add a mob's ID and Path Length
							|/echo Adding a mob to the pullList
							/varset PullList[${j},1] ${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].ID}
							/varset PullList[${j},2] ${Int[${Navigation.PathLength[id ${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].ID}]}]}
							|If this is the first mob I've added to the array, it is now my target and it has the shortest path. 
							/if (${j}==1) {
								/varset PullTargetID ${PullList[${j},1]}
								/varset Shortest ${PullList[${j},2]}
							} else /if (${PullList[${j},2]} < ${Shortest}) {
								|Otherwise if the mob I added has a PathLength shorter that the current shortest Nav Path, make it my target and set it as the shortest.
								/varset PullTargetID ${PullList[${j},1]}
								/varset Shortest ${PullList[${j},2]}
							}
							|Since I added a mob I need to increment j by 1 in the PullList Array. 
							/varcalc j ${j}+1
						}
					} else {
						/if (${Debugging}) {
							/squelch /echo \at${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].Name} was not a valid pull target.
							/squelch /echo \ar${Navigation.PathExists[id ${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].ID}]} && ${Int[${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].Distance3D}]} <= ${Int[${Navigation.PathLength[id ${NearestSpawn[${i},npc noalert 1 targetable radius ${PullRange} zradius ${ZRadius} "${FarmMob}"].ID}]}]}
						}
					}
				}
			|Check the next mob in the NearestSpawn meeting my conditions loop 
			/next i
			|Now that I've exited the loop, the PullTargetID variable is the one I want to navigate to and kill. 
			/if (${PullTargetID}) {
				/varset myTargetID ${PullTargetID}
				|Set the chattitle of the MQ2 window to the macro's status (Suggestion by Kaen01)
				/setchattitle Going to kill ${Spawn[id ${myTargetID}].CleanName}!
			}
		} else /if (${Me.Standing}) {
			/if (!${Me.Casting.ID} && !${SitDelay} && !${Me.Moving} && !${Me.Mount.ID}) {
				/sit
				/varset SitDelay ${SitDelay.OriginalValue}
			}
		}
	} else /if (!${Me.XTarget[1].Type.Equal[Corpse]}) {
		/varset myTargetID ${Me.XTarget[1].ID}
		|/if (${Debugging}) /echo \atI had an XTarget and have set myTargetID: ${myTargetID} - ${Spawn[${myTargetID}].Name}
	}
/return

| --------------------------------------------------------------------------------------------
| SUB: GroupManaChk
| --------------------------------------------------------------------------------------------
Sub GroupManaChk
	/if (${Me.XTarget[1].ID}) /return
	 
	/if (!${Me.Combat}) {
		/setchattitle "Group Mana Check"
		/if (${Me.PctMana} < ${MedAt} && ${Me.Class.CanCast} && !${Me.State.Equal[DEAD]}) {
			/echo \arYOU are low on mana!
			/setchattitle "Waiting on YOUR mana to reach ${MedTill}%"
			/if (!${Me.XTarget[1].ID}) {
				/if (${UseEQBC}) {
					/bccmd names
				}
				/while (${Me.PctMana} < ${MedTill} && !${Me.XTarget[1].ID} && !${Me.State.Equal[DEAD]}) {
					/doevents
					/if (${Me.Standing} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${SitDelay}) {
						/sit
						/varset SitDelay ${SitDelay.OriginalValue}
					}
					/if (${UseEQBC}) {
						/if (!${Defined[j]}) /declare j int local
						/for j 1 to ${Group}
							/if (${Debugging}) /echo \ayConnect to the server? : ${EQBC.Names.Find[${Group.Member[${j}].Name}]}
							/if (${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]} && !${SitDelay}) {
								/bct ${Group.Member[${j}].Name} //sit
								/varset SitDelay ${SitDelay.OriginalValue}
							}
						/next j
					}
					/delay 10
				}
				/if (${UseEQBC}) {
					/bcaa //stand
				}
			}
		}
		/if (${Group}) {
			/declare i int local
			/for i 1 to ${Group}
				/if ((${Group.Member[${i}].PctMana} < ${MedAt}) && ${Group.Member[${i}].Class.CanCast} && !${Group.Member[${i}].State.Equal[DEAD]}) {
					/doevents
					/echo \ar${Group.Member[${i}].Name} is low on mana!
					/setchattitle "Waiting on ${Group.Member[${i}].Name}'s mana to reach ${MedTill}%"
					/if (!${Me.XTarget[1].ID}) {
						/if (${UseEQBC}) {
							/bccmd names
						}
						/while (${Group.Member[${i}].PctMana} < ${MedTill} && !${Me.XTarget[1].ID} && !${Group.Member[${i}].State.Equal[DEAD]}) {
							/if (${Me.Standing} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${Me.Moving}) {
								/sit
								/varset SitDelay ${SitDelay.OriginalValue}
							}
							/if (${UseEQBC}) {
							/if (!${Defined[j]}) /declare j int local
								/for j 1 to ${Group}
									/if (${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && !${Group.Member[${j}].State.Equal[DEAD]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]} && !${SitDelay}) {
										/if (${Debugging}) /echo ${Group.Member[${j}].Name} was connected to EQBC and not sitting. So I'm going to get them to sit. 
										/bct ${Group.Member[${j}].Name} //sit
										/varset SitDelay ${SitDelay.OriginalValue}
									}
								/next j
							}
							/delay 10
						}
						/if (${UseEQBC}) {
							/bcaa //stand
						}
					}
				}
			/next i
		}
	}
/return

| --------------------------------------------------------------------------------------------
| SUB: GroupHealthChk
| --------------------------------------------------------------------------------------------
Sub GroupHealthChk
	/if (${Me.XTarget[1].ID}) /return
	 
	/setchattitle "GroupHealthCheck"
	/if (!${Me.Combat}) {
		/if (${Me.PctHPs} < ${HealAt} && !${Me.State.Equal[DEAD]}) {
			/echo \arYOU are low on Health!
			/setchattitle "Waiting on YOUR health to reach ${HealTill}%"
			/if (!${Me.XTarget[1].ID}) {
				/if (${UseEQBC}) {
					/bccmd names
				}
				/while (${Me.PctHPs} < ${HealTill} && !${Me.XTarget[1].ID} && !${Me.State.Equal[DEAD]}) {
					/doevents
					/if (${Me.Standing} && !${Me.Moving} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${SitDelay}) {
						/sit
						/varset SitDelay ${SitDelay.OriginalValue}
					}
					/if (${UseEQBC}) {
						/if (!${Defined[j]}) /declare j int local
						/for j 1 to ${Group}
							/if (${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && !${Group.Member[${j}].State.Equal[DEAD]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]} && !${SitDelay}) {
								/if (${Debugging}) /echo ${Group.Member[${j}].Name} was connected to EQBC and not sitting. So I'm going to get them to sit. 
								/bct ${Group.Member[${j}].Name} //sit
								/varset SitDelay ${SitDelay.OriginalValue}
							}
						/next j
					}
					/delay 10
				}
				/if (${UseEQBC}) {
					/bcaa //stand
				}
			}
		}
		/if (${Group}) {
			/declare i int local
			/for i 1 to ${Group}
				/if (${Group.Member[${i}].ID}) {
					/if (${Group.Member[${i}].PctHPs} < ${HealAt} && !${Group.Member[${i}].State.Equal[DEAD]}) {
						/echo ${Group.Member[${i}].Name} is low on Health!
						/setchattitle "Waiting on ${Group.Member[${i}].Name} health to reach ${HealTill}%"
						/if (!${Me.XTarget[1].ID}) {
							/if (${UseEQBC}) {
								/bccmd names
							}
							/while (${Group.Member[${i}].PctHPs} < ${HealTill} && !${Me.XTarget[1].ID} && !${Group.Member[${i}].State.Equal[DEAD]}) {
								/doevents
								/if (${Me.Standing} && !${Me.Moving} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${SitDelay}) {
									/sit
									/varset SitDelay ${SitDelay.OriginalValue}
								}
								/if (${UseEQBC}) {
									/if (!${Defined[j]}) /declare j int local
									/for j 0 to ${Group}
									/if (!${SitDelay} && ${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && !${Group.Member[${j}].State.Equal[DEAD]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]}) {
										/echo ${Group.Member[${j}].Name} was connected to EQBC and not sitting. So I'm going to get them to sit. 
										/bct ${Group.Member[${j}].Name} //sit
										/varset SitDelay ${SitDelay.OriginalValue}
									}
									/next j
								}
								/delay 10
							}
							/if (${UseEQBC}) {
								/bcaa //stand
							}
						}
					}
				}
			/next i
		}
	}
/return

| --------------------------------------------------------------------------------------------
| SUB: GroupEndChk
| --------------------------------------------------------------------------------------------
Sub GroupEndChk
	/if (${Me.XTarget[1].ID}) /return
	 
	/setchattitle "GroupEnduranceCheck"
	/if (!${Me.Combat}) {
		/if (${Me.PctEndurance} < ${MedEndAt} && !${Me.State.Equal[DEAD]}) {
			/echo \arYOU are low on Endurance!
			/setchattitle "Waiting on YOUR Endurance to reach ${MedEndTill}%"
			/if (!${Me.XTarget[1].ID}) {
				/if (${UseEQBC}) {
					/bccmd names
				}
				/while (${Me.PctEndurance} < ${MedEndTill} && !${Me.XTarget[1].ID} && !${Me.State.Equal[DEAD]}) {
					/doevents
					/if (${Me.Standing} && !${Me.Moving} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${SitDelay}) {
						/sit
						/varset SitDelay ${SitDelay.OriginalValue}
					}
					/if (${UseEQBC}) {
						/if (!${Defined[j]}) /declare j int local
						/for j 1 to ${Group}
							/if (!${SitDelay} && ${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]}) {
								/bct ${Group.Member[${j}].Name} //sit
								/varset SitDelay ${SitDelay.OriginalValue}
							}
						/next j
					}
					/delay 10
				}
				/if (${UseEQBC}) {
					/bcaa //stand
				}
			}
		}
		/if (${Group}) {
			/declare i int local
			/for i 1 to ${Group}
				/if (${Group.Member[${i}].ID}) {
					/if (${Group.Member[${i}].PctEndurance} < ${MedEndAt} && !${Group.Member[${i}].State.Equal[DEAD]}) {
						/echo \ar${Group.Member[${i}].Name} is low on Endurance!
						/setchattitle "Waiting on ${Group.Member[${i}].Name} Endurance to reach ${MedEndTill}%"
						/if (!${Me.XTarget[1].ID}) {
							/if (${UseEQBC}) {
								/bccmd names
							}
							/while (${Group.Member[${i}].PctEndurance} < ${MedEndTill} && !${Me.XTarget[1].ID} && !${Group.Member[${i}].State.Equal[DEAD]}) {
								/doevents
								/if (${Me.Standing} && !${Me.Moving} && !${Me.Casting.ID} && !${Me.Mount.ID}) {
									/sit
									/varset SitDelay ${SitDelay.OriginalValue}
								}
								/if (${UseEQBC}) {
									/if (!${Defined[j]}) /declare j int local
									/for j 0 to ${Group}
										/if (!${SitDelay} && ${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && !${Group.Member[${j}].State.Equal[DEAD]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]}) {
											/echo ${Group.Member[${j}].Name} was connected to EQBC and not sitting. So I'm going to get them to sit. 
											/bct ${Group.Member[${j}].Name} //sit
											/varset SitDelay ${SitDelay.OriginalValue}
										}
									/next j
								}
								/delay 10
							}
							/if (${UseEQBC}) {
								/bcaa //stand
							}
						}
					}
				}
			/next i
		}
	}
/return

| --------------------------------------------------------------------------------------------
| SUB: GroupDeathChk
| --------------------------------------------------------------------------------------------
Sub GroupDeathChk
	
	/if (${Me.State.Equal[DEAD]}) {
		/echo \arYOU~ have died! Waiting for YOU to get off your face.
		/setchattitle "You died, waiting for rez!"
		/while (${Me.State.Equal[DEAD]} ) {
			/delay 10
		}
	}
	/if (${Me.XTarget[1].ID}) /return
	/if (${Group}) {
		/declare i int local
		/for i 1 to ${Group}
			/if (${Group.Member[${i}].State.Equal[DEAD]} ) {
				/echo ${Group.Member[${i}].Name} has died. Waiting for them to get off their face.
				/setchattitle "${Group.Member[${i}].Name} has died. Waiting for Rez"
				/if (!${Me.XTarget[1].ID}) {
					/if (${UseEQBC}) {
						/bccmd names
					}
					/while (${Group.Member[${i}].State.Equal[DEAD]} && !${Me.XTarget[1].ID}) {
						/doevents
						/if (${Me.Standing} && !${Me.Moving} && !${Me.Casting.ID} && !${Me.Mount.ID} && !${SitDelay}) {
							/sit
							/varset SitDelay ${SitDelay.OriginalValue}
						}
						/if (${UseEQBC}) {
							/if (!${Defined[j]}) /declare j int local
							/for j 0 to ${Group}
								/if (${j} != ${i}) {
									/if (${Debugging}) /echo \ayConnect to the server? : ${EQBC.Names.Find[${Group.Member[${j}].Name}]}
									/if (${Group.Member[${j}].State.Equal[Stand]} && !${Group.Member[${j}].Type.Equal[Mercenary]} && !${Group.Member[${j}].State.Equal[DEAD]} && ${EQBC.Names.Find[${Group.Member[${j}].Name}]} && !${SitDelay}) {
										/bct ${Group.Member[${j}].Name} //sit
										/varset SitDelay ${SitDelay.OriginalValue}
									}
								}
							/next j
						}
						/delay 10
					}
				}
			}
		/next i
	}
/return

Sub WaitNav(NavTargetID, distance)
	/if (${distance}) /echo Distance from mob nav target to stop: ${distance}
	:keepGoing
	/if (${Debugging}) /echo NavTest Variables: ${Spawn[id ${NavTargetID}].Distance} > ${If[${distance},${distance},20]} || !${Spawn[id ${NavTargetID}].LineOfSight}
	/if (${Spawn[id ${NavTargetID}].Distance} > ${If[${distance},${distance},20]} || !${Spawn[id ${NavTargetID}].LineOfSight}) {
		/if (${Navigation.Active}) {
			/if (${Me.XTarget[1].ID}) {
				/if (${Navigation.Active}) /squelch /nav stop
				/call FarmStuff
			} else {
				/call GroupDeathChk
				/call GroupHealthChk
				/call GroupEndChk
				/call GroupManaChk
				/call CheckMerc
			}
			/if (${Me.Combat} && !${Me.XTarget[1].ID}) /squelch /target clear
			/if (!${courseCorrection}) {
				/squelch /nav id ${NavTargetID}
				/varset courseCorrection ${courseCorrection.OriginalValue}
			}
			/delay 5
		} else {
			/if (${Me.XTarget[1].ID}) {
				/if (${Navigation.Active}) /squelch /nav stop
				/if (${UseEQBC}) {
					/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target xtarget ${Spawn[id ${Me.XTarget[1].ID}].Name}
					/bcaa //target id ${Me.XTarget[1].ID}
				} else {
					/target id ${Me.XTarget[1].ID}
				}
				/call FarmStuff
			} else /if (!${Target.ID} && ${Spawn[${myTargetID}].LineOfSight} && ${Spawn[${myTargetID}].Distance3D} < 100) {
				/target id ${myTargetID}
				/delay 2s ${Target.ID}==${myTargetID}
				/killthis
			} else {
				/call GroupDeathChk
				/call GroupHealthChk
				/call GroupEndChk
				/call GroupManaChk
				/call CheckMerc
			}
			/if (${Me.Combat} && !${Me.XTarget[1].ID}) /squelch /target clear
			/squelch /nav id ${NavTargetID}
			/if (${UseEQBC} && !${Me.CombatState.Equal[Combat]}) {
				/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target me and stick (WaitNav).
				/bca //target id ${Me.ID}
				/delay 5
				/bca //stick 10 loose moveback uw behind
			}
		}
	}
	/if (${Spawn[id ${NavTargetID}].Distance} > ${If[${distance},${distance},20]} || !${Spawn[id ${NavTargetID}].LineOfSight}) /goto :keepGoing
	/if (${Debugging}) /echo Stopped Distance from Target: ${Spawn[id ${NavTargetID}].Distance}
	/if (${Navigation.Active}) /squelch /nav stop
	:target
	/if (${UseEQBC} && ${assistMe}) {
		/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target NavTarget ${Spawn[id ${NavTargetID}].Name}
		/bcaa //target id ${NavTargetID}
	} else {
		/target id ${NavTargetID}
	}
	/delay 2s ${Target.CleanName.Equal[${Spawn[id ${NavTargetID}].CleanName}]}
	/if (!${Target.CleanName.Equal[${Spawn[id ${NavTargetID}].CleanName}]} && ${Spawn[id ${NavTargetID}].ID}) {
		/goto :target
	}
/return

Sub NavToLoc(int Y,int X,int Z)
	/while (${Math.Distance[${Me.Y}, ${Me.X}, ${Me.Z}: ${Y}, ${X}, ${Z}]} > 15) {
		/if (${Navigation.Active}) {
			/if (${Me.XTarget[1].ID}) {
				/if (${Navigation.Active}) /nav stop
				/call FarmStuff
			} else {
				/call GroupDeathChk
				/call GroupHealthChk
				/call GroupEndChk
				/call GroupManaChk
				/call CheckMerc
			}
			/if (${Me.Combat} && !${Me.XTarget[1].ID}) /squelch /target clear
			/delay 10
		} else {
			/if (${Me.XTarget[1].ID}) {
				/if (${Navigation.Active}) /nav stop
				/call FarmStuff
			} else {
				/call GroupDeathChk
				/call GroupHealthChk
				/call GroupEndChk
				/call GroupManaChk
				/call CheckMerc
			}
			/if (${Me.Combat} && !${Me.XTarget[1].ID}) /squelch /target clear
			/nav loc ${Y} ${X} ${Z}
		}
	}
	/if (${Navigation.Active}) /nav stop
/return

Sub FarmStuff(string Enemy)
	/if (${Bool[${Enemy}]}) {
		/varset FarmMob ${Enemy}
		/if (${Debugging} && !${reportTarget}) {
			/echo Looking for: ${FarmMob}
			/varset reportTarget ${reportTarget.OriginalValue}
		}
	} else /if (!${reportTarget}) {
		/echo Attacking anything I can get my grubby paws on.
		/varset reportTarget ${reportTarget.OriginalValue}
	}
	:findMob
	/if (${Target.Type.Equal[corpse]}) {
		/if (${Target.ID} == ${myTargetID}) /varset myTargetID 0
		/squelch /target clear
	}
	/if (${Window[RespawnWnd].Open}) /call GroupDeathChk
	/if (!${Me.XTarget[1].ID} || !${Window[RespawnWnd].Open}) {
		/call GroupDeathChk
		/call GroupHealthChk
		/call GroupEndChk
		/call GroupManaChk
	}
	|/if (${Debugging}) /echo \aymyTargetID has an ID: ${Spawn[id ${myTargetID}].ID} - is a corpse: ${Spawn[id ${myTargetID}].Type.Equal[Corpse]} - I have an XTarget: !${Me.XTarget[1].ID}																																												   
	/if (!${Spawn[id ${myTargetID}].ID} || ${Spawn[id ${myTargetID}].Type.Equal[Corpse]} && !${Me.XTarget[1].ID}) {
		/varset myTargetID 0
		/call TargetShortest
		/if (${Debugging} && ${myTargetID} && ${Spawn[id ${myTargetID}].Type.NotEqual[corpse]}) /echo Target is ${Spawn[id ${myTargetID}]}	  
	} else {
		/if (${Debugging}) /echo \ayI have an XTarget so I'm going to set that as my target. 
		/varset myTargetID ${Me.XTarget[1].ID}
		/call Combat
	}
	:navto
	|/if (${Debugging}) /echo ${Spawn[${myTargetID}].Distance} > ${If[${PullAbilityRange},${PullAbilityRange},1]} && !${Me.XTarget[1].ID} ${If[${PullRequiresLineOfSight}, || !${Spawn[${myTargetID}].LineOfSight},]}
	/if (${Spawn[${myTargetID}].Distance} > ${If[${PullAbilityRange},${PullAbilityRange},1]} && !${Me.XTarget[1].ID} ${If[${PullRequiresLineOfSight}, || !${Spawn[${myTargetID}].LineOfSight},]}) {
		/if (!${Bool[${Spawn[${myTargetID}].ID}]}) {
			|/if (${Debugging}) /echo \ar My target ID was null, so I'm returning out of the sub.
			/varset myTargetID 0
			/return
		}
		/echo \ayNavigating to \aw--> \ap${Spawn[${myTargetID}].CleanName}
		/if (!${Select[${PullAbility},Ranged,Throwing,Archery,Bow]}) {
			/call WaitNav ${myTargetID} ${PullAbilityRange}
			/delay 10
			/goto :navto
		}
	} else /if (!${Target.ID} && ${Target.ID} != ${myTargetID} && ${Target.ID} != ${Me.ID} && ${myTargetID} != 0 && !${Me.XTarget[1].ID}) {
		/if (${Debugging}) /echo I'm targeting ${Spawn[${myTargetID}].CleanName} ID: ${myTargetID}
		/if (${UseEQBC} && ${assistMe}) {
			/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target myTargetID ${Spawn[id ${myTargetID}].Name}
			/bcaa //target id ${myTargetID}
		} else {
			/target id ${myTargetID}
		}
		/delay 1s ${Target.ID}==${myTargetID}
	}
	/delay 5
	/if (${PullCommand.Length}) {
		/call PullAbility
	} else {
		/call WaitNav ${myTargetID} 20
		/call Combat
	}
/return

Sub Combat
	/if (${Target.ID} && (${Target.Type.Equal[npc]} || ${Target.Type.Equal[pet]})) {
		/declare i int local 0
		/if (${Navigation.Active}) /squelch /nav stop
		/stick uw loose moveback behind 8 
		/setchattitle Killing ${Target.CleanName}
		/if (${UseEQBC} && ${assistMe}) {
			/if (${Debugging}) /bc (Line: ${Macro.CurLine}) killthis
			/timed 10 /bca //pet attack
			/timed 15 /bca //pet swarm
			/timed 20 /bca //killthis
		}
		/pet attack
		/pet swarm
		/killthis
		:waitTillDead
		/if (${Me.Sitting}) /stand
		/if (${Target.ID} && ${Me.CombatState.Equal[Combat]} && ${Target.Type.Equal[npc]}) {
			/if (!${Me.Combat}) /attack
			/if (${Me.Class.CanCast}) {
				/if (${CastDetrimental}) {
					/if (!${Me.Casting.ID}) {
						/for i 1 to ${Me.NumGems}
							/if (!${Me.XTarget}) /break
							/if (${Me.Gem[${i}].ID}) {
								/if (${Me.Gem[${i}].TargetType.Equal[Single]} && ${Me.Gem[${i}].SpellType.Equal[Detrimental]} !${Target.Buff[${Me.Gem[${i}].Name}].ID}) {
									/cast ${i}
									/delay 3s ${Me.Casting.ID}
									/echo \agCasting \am${Me.Gem[${i}]} \aw--> \ar${Target.CleanName}
									/delay ${Math.Calc[${Me.Gem[${i}].CastTime.TotalSeconds}+2].Int}s !${Me.Casting.ID}
								}
							}
						/next i
					}
				}
			}
			/delay 10
			/goto :waitTillDead
		} else /if (${Target.Type.Equal[corpse]}) {
			/squelch /target clear
			/varset myTargetID 0
		}
	} else /if (${Me.XTarget[1].ID}) {
		/if (${Spawn[id ${Me.XTarget[1].ID} radius 30 zradius 50].ID} && ${Spawn[id ${Me.XTarget[1].ID} radius 30 zradius 50].LineOfSight}) {
			/if (${Navigation.Active}) /squelch /nav stop
			/if (${UseEQBC} && ${assistMe}) {
				/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target XTarget ${Spawn[id ${Me.XTarget[1].ID}].Name}
				/bcaa //target id ${Me.XTarget[1].ID}
			} else {
				/target id ${Me.XTarget[1].ID}
			}
			/setchattitle Handling add, ${Spawn[${Me.XTarget[1].ID}].CleanName}
		} else /if (${Spawn[id ${Me.XTarget[1].ID}].Distance} > 30 || !${Spawn[id ${Me.XTarget[1].ID} radius 30 zradius 50].LineOfSight}) {
			/if (${Navigation.PathExists[id ${NavTargetID}]}) /squelch /nav id ${Me.XTarget[1].ID}
			/if (${UseEQBC} && !${Me.CombatState.Equal[Combat]}) {
				/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target me and stick (FarmStuff1).
				/bca //target id ${Me.ID}
				/delay 5
				/bca //stick 10 loose moveback uw
			}
			/setchattitle Navigating to add ${Spawn[id ${Me.XTarget[1].ID}].CleanName}
			/while (${Spawn[${Me.XTarget[1].ID}].Distance} > 30) {
				/if (!${Navigation.Active}) {
					/squelch /nav id ${Me.XTarget[1].ID}
					/if (${UseEQBC} && !${Me.CombatState.Equal[Combat]}) {
						/if (${Debugging}) /bc (Line: ${Macro.CurLine}) target me and stick (FarmStuff2).
						/bca //target id ${Me.ID}
						/delay 5
						/bca //stick 10 loose moveback uw
					}
				}
				/delay 10
				/if (!${courseCorrection}) {
					/squelch /nav id ${Me.XTarget[1].ID}
					/varset courseCorrection ${courseCorrection.OriginalValue}
				}
			}
		}
		/if (${UseEQBC} && ${assistMe}) {
			/if (${Debugging}) /bc (Line: ${Macro.CurLine}) killthis						   
			/timed 10 /bca //pet attack
			/timed 15 /bca //pet swarm
			/timed 20 /bca //killthis
		}
		/pet attack
		/pet swarm
		/killthis
		/setchattitle Killing ${Target.CleanName}
		/goto :waitTillDead
	}
/return

Sub PullAbility
	/docommand ${If[${PullAbilityRange}>30,/if (${Navigation.Active}) /nav stop,/stick moveback uw 10]}
	:PullAbility
	/if (${Spawn[${myTargetID}].Distance} > ${If[${PullAbilityRange},${PullAbilityRange},1]} && !${Me.XTarget[1].ID} || !${Spawn[${myTargetID}].LineOfSight}) /return
	|/if (${Debugging}) /echo \ayPull Ability - Ability: ${Me.AbilityReady[${PullAbility}]} || Spell: ${Me.SpellReady[${PullAbility}]} || AltAbility: ${Me.AltAbilityReady[${PullAbility}]} || CombatAbility: ${Me.CombatAbilityReady[${PullAbility}]}
	/if (${Me.AbilityReady[${PullAbility}]} || ${Me.SpellReady[${PullAbility}]} || ${Me.AltAbilityReady[${PullAbility}]} || ${Me.CombatAbilityReady[${PullAbility}]} || ${PullAbility.Equal[pet]} || !${FindItem[=${PullAbility}].TimerReady}) {
		/if (${Debugging}) /echo \arShould be issuing the PullCommand ${PullCommand}
		/if (!${Me.XTarget} && ${PullAbility.NotEqual[pet]}) {
			/docommand ${PullCommand}
		} else /if (${PullAbility.Equal[pet]}) {
			/call PetPull
		}
	}
	/if (${Me.XTarget}) { 
		/squelch /target id ${Me.XTarget[1].ID}
		/delay 2s ${Target.ID}==${Me.XTarget[1].ID}
		/if (${Target.ID} != ${myTargetID}) /varset myTargetID ${Target.ID}
		/call Combat
	} else /if (${Spawn[id ${myTargetID}].Type.NotEqual[Corpse]} && ${Spawn[id ${myTargetID}].ID}) {
		|/if (${Debugging}) /echo \aymyTargetID not a corpse: ${Spawn[id ${myTargetID}].Type.NotEqual[Corpse]} - Has an ID: ${Spawn[id ${myTargetID}].ID} == ${myTargetID}
		/delay 1s ${Me.XTarget[1].ID}
		/goto :PullAbility
	}
/return

Sub CheckMerc
	/if (${Mercenary.State.Equal[DEAD]} && ${UseMerc}) {
		/echo Your mercenary has died. Waiting to be able to revive them. 
		:waitForMerc
		/if (${Group} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Tooltip.Equal[Revive your current mercenary.]} && ${Window[MMGW_ManageWnd].Child[MMGW_SuspendButton].Enabled}) /notify MMGW_ManageWnd MMGW_SuspendButton leftmouseup
		/delay 2s
		/if (${Mercenary.State.Equal[DEAD]} && !${Me.XTarget[1].ID}) /goto :waitForMerc
	}
/return

Sub XTargetCheck
	/declare i int local
	/for i 1 to ${Me.XTarget}
		/if (${Me.XTarget[${i}].TargetType.Equal[Auto Hater]}) /return TRUE
	/next i
/return FALSE

Sub Bind_AddToIgnore
	/alert add 1 ${Target.CleanName}
	/varset myTargetID 0
	/squelch /target clear
/return 

Sub Bind_AddThisIgnore
	/alert add 1 ${Target.Name}
	/varset myTargetID 0
	/squelch /target clear
	/delay 5
/return

Sub Bind_PermIgnore
	/ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Ignored" "${If[${Bool[${Ini[FarmMobIgnored.ini,${Zone.ShortName},Ignored]}]},${Ini[FarmMobIgnored.ini,${Zone.ShortName},Ignored]},]}${Target.CleanName}|"
	/varset myTargetID 0
	/squelch /target clear
/return

	


Sub GenerateList
	/declare i int local
	/echo \ayGetting Named Mobs currently up in ${Zone}.
	/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Ignored].Length}) /ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Ignored" "|"
	/for i 1 to ${SpawnCount[npc named]}
		/if (${NearestSpawn[${i},npc named].Name.NotEqual[NULL]}) {
			/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},NamedList].Find[${NearestSpawn[${i},npc named].CleanName}]}) {
				/if (${Ini[FarmMobIgnored.ini,${Zone.ShortName},NamedList].Length} < 1900) {	
					/echo \ayFound - \ar${NearestSpawn[${i},npc named].CleanName}
					/ini "FarmMobIgnored.ini" "${Zone.ShortName}" "NamedList" "${If[${Bool[${Ini[FarmMobIgnored.ini,${Zone.ShortName},NamedList]}]},${Ini[FarmMobIgnored.ini,${Zone.ShortName},NamedList]},]}${NearestSpawn[${i},npc named].CleanName}|"
				}
			}
		}
	/next i
	/echo \ayGetting Merchants currently up in ${Zone}.
	/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Merchants].Length}) /ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Merchants" "|"
	/for i 1 to ${SpawnCount[Merchant]}
		/if (${NearestSpawn[${i},Merchant].Name.NotEqual[NULL]}) {
			/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Merchants].Find[${NearestSpawn[${i},Merchant].CleanName}]}) {
				/if (${Ini[FarmMobIgnored.ini,${Zone.ShortName},Merchants].Length} < 1900) {	
					/echo \ayFound - \ar${NearestSpawn[${i},Merchant].CleanName}
					/ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Merchants" "${If[${Bool[${Ini[FarmMobIgnored.ini,${Zone.ShortName},Merchants]}]},${Ini[FarmMobIgnored.ini,${Zone.ShortName},Merchants]},]}${NearestSpawn[${i},Merchant].CleanName}|"
				} else {
					/echo The Merchants list was too large and was cut short.
					/break
				}
			}
		}
	/next i
	/echo \ayGetting Bankers currently up in ${Zone}.
	/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Bankers].Length}) /ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Bankers" "|"
	/for i 1 to ${SpawnCount[Banker]}
		/if (${NearestSpawn[${i},Banker].Name.NotEqual[NULL]}) {
			/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Bankers].Find[${NearestSpawn[${i},Banker].CleanName}]}) {
				/if (${Ini[FarmMobIgnored.ini,${Zone.ShortName},Bankers].Length} < 1900) {
					/echo \ayFound - \ar${NearestSpawn[${i},Banker].CleanName}
					/ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Bankers" "${If[${Bool[${Ini[FarmMobIgnored.ini,${Zone.ShortName},Bankers]}]},${Ini[FarmMobIgnored.ini,${Zone.ShortName},Bankers]},]}${NearestSpawn[${i},Banker].CleanName}|"
				} else {
					/echo The Bankers list was too large and was cut short.
					/break
				}
			}
		}
	/next i
	/echo \ayGetting Objects currently up in ${Zone}.
	/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Objects].Length}) /ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Objects" "|"
	/for i 1 to ${SpawnCount[Object]}
		/if (${NearestSpawn[${i},Object].Name.NotEqual[NULL]}) {
			/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},Objects].Find[${NearestSpawn[${i},Object].CleanName}]}) {
				/if (${Ini[FarmMobIgnored.ini,${Zone.ShortName},Objects].Length} < 1900) {
					/echo \ayFound - \ar${NearestSpawn[${i},Object].CleanName}
					/ini "FarmMobIgnored.ini" "${Zone.ShortName}" "Objects" "${If[${Bool[${Ini[FarmMobIgnored.ini,${Zone.ShortName},Objects]}]},${Ini[FarmMobIgnored.ini,${Zone.ShortName},Objects]},]}${NearestSpawn[${i},Object].CleanName}|"
				} else {
					/echo The Objects list was too large and was cut short.
					/break
				}
			}
		}
	/next i
	/echo \ayGetting NPCs currently up in ${Zone}.
	/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},NPCs].Length}) /ini "FarmMobIgnored.ini" "${Zone.ShortName}" "NPCs" "|"
	/for i 1 to ${SpawnCount[npc]}
		/if (${NearestSpawn[${i},NPC].Name.NotEqual[NULL]} && !${NearestSpawn[${i},NPC].Named}) {
			/if (!${Ini[FarmMobIgnored.ini,${Zone.ShortName},NPCs].Find[${NearestSpawn[${i},NPC].CleanName}]}) {
				/if (${Ini[FarmMobIgnored.ini,${Zone.ShortName},NPCs].Length} < 1900) {
					/echo \ayFound - \ar${NearestSpawn[${i},NPC].CleanName}
					/ini "FarmMobIgnored.ini" "${Zone.ShortName}" "NPCs" "${If[${Bool[${Ini[FarmMobIgnored.ini,${Zone.ShortName},NPCs]}]},${Ini[FarmMobIgnored.ini,${Zone.ShortName},NPCs]},]}${NearestSpawn[${i},NPC].CleanName}|"
				} else {
					/echo The NPCs list was too large and was cut short.
					/break
				}
			}
		}
	/next i
	/echo \agDone, list is stored in FarmMobIgnored.ini
/return

Sub GetRangedInfo
	|If I have a bow and arrow set, or if My Ranged item is a throwing item -- Lets set ammo and ranged type.
	/if ((${Me.Inventory[11].Type.Equal[Archery]} && ${Me.Inventory[22].Type.Equal[Arrow]}) || ${Me.Inventory[11].Type.Find[Throwing]} && ${Me.Inventory[22].Type.Find[Throwing]}) {
		|Set the ammo and AmmoRange
		/if (${Me.Inventory[22].Type.Equal[Arrow]}) {
			/if (${Debugging}) /echo MyAmmo: ${Me.Inventory[22].Name}
			/declare MyAmmo string outer ${Me.Inventory[22].Name}
			/declare AmmoRange int outer ${FindItem[${MyAmmo}].Range}
		} else /if (${Me.Inventory[11].Type.Find[Throwing]}) {
			/if (${Debugging}) /echo MyAmmo: ${Me.Inventory[11].Name}
			/declare MyAmmo string outer ${Me.Inventory[11].Name}
			/declare AmmoRange int outer ${FindItem[${MyAmmo}].Range}
		} else {
			/declare MyAmmo string outer NULL
			/declare AmmoRange int outer 0
		}
		/if (${Debugging}) /echo ${FindItem[${MyAmmo}].Range}
		|Set the ranged type.
		/if (${Me.Inventory[11].Type.Equal[Archery]}) {
			/if (${Debugging}) /echo Setting Ranged type to Archery
			/declare RangedType int outer 1
		} else /if (${Me.Inventory[11].Type.Find[Throwing]}) {
			/if (${Debugging}) /echo Setting Ranged type to Throwing
			/declare RangedType int outer 2
		} else {
			/declare RangedType int outer 0
		}
		|If Ranged type is Archery then get the range of the bow and combine it with the range of the arrow.
		/if (${RangedType} == 1) {
			/varcalc AmmoRange ${AmmoRange}+${Me.Inventory[11].Range}
			/echo Total Range with Archery is: ${AmmoRange}
		} else /if (${RangedType} == 2) {
			/echo Total Range with Throwing is: ${AmmoRange}
		}
	}
/return

Sub RangedPull
	/if (!${FindItemCount[${MyAmmo}]}) {
		/echo Out of Ammo!
		/varset PullCommand 
	}
	/if (${Spawn[id ${myTargetID}].ID} && ${Spawn[id ${myTargetID}].Type.NotEqual[Corpse]}) {
		/if (${Spawn[id ${myTargetID}].Distance3D} > ${AmmoRange} || !${Spawn[id ${myTargetID}].LineOfSight}) {
			/call WaitNav ${myTargetID} ${Math.Calc[${AmmoRange}*0.90].Int}
		}
		/if (${Spawn[id ${myTargetID}].Distance3D} < ${AmmoRange} && ${Spawn[id ${myTargetID}].Distance3D} > 35 && ${Spawn[id ${myTargetID}].LineOfSight}) {
			/target id ${myTargetID}
			/delay 1s ${Target.ID}==${myTargetID}
			/declare PullTimer timer local 100
			/face fast
			/autofire on
			:waitForMob
			/if (${Target.Distance} > 40) {
				/delay 5
				/if (${PullTimer}) {
					/echo PullTimer: ${PullTimer}
					/goto :waitForMob
				} else /if (!${PullTimer} && !${Me.XTarget[1].ID}) {
					/echo Something was wrong with that target, adding it to alert list 1. 
					/ignorethis
				}
			}
			/autofire off
			/call Combat
		} else /if (${Spawn[id ${myTargetID}].Distance3D} > 35) {
			/target id ${myTargetID}
			/delay 1s ${Target.ID}==${myTargetID}
			/face fast
			/call Combat
		}
	}
/return

Sub CheckINI(string IniName,string Section,string Key,string TypeVar,Default)
	/if (!${Ini[${IniName},${Section},${Key}].Length}) {
		/ini ${IniName} ${Section} ${Key} ${Default}
	}
	/declare ${Key} ${TypeVar} outer ${Ini[${IniName},${Section},${Key}]}
	/if (${Debugging}) /echo \atLoading INI ${IniName} ~ Key: ${Key} Type: ${TypeVar} INI Value: ${Ini[${IniName},${Section},${Key}]}
/return

Sub CheckPlugin(PluginName, Option)
	/if (${Debugging}) /echo Sub CheckPlugin Entry
	/if (!${Option.Length}) /varset Option on
	/if (${Option.Equal[on]}) {
		/if (!${Plugin[${PluginName}].Name.Equal[${PluginName}]}) {
			/plugin ${PluginName}
			/delay 3s ${Plugin[${PluginName}].Name.Equal[${PluginName}]}
			/if (!${Plugin[${PluginName}].Name.Equal[${PluginName}]}) {
				/echo "The Plugin --> ${PluginName} didn't load for some reason."
				/varset Endmac TRUE
			}
			/if (${PluginName.Equal[MQ2Nav]}) {
				/delay 2s
			}
		}
		/if (${PluginName.Equal[MQ2EQBC]}) {
			/if (!${EQBC.Connected}) {
				/bccmd connect
				/delay 3s ${EQBC.Connected}
				/if (!${EQBC.Connected}) {
					/echo "\arCould not connect to the EQBC Server. Are you sure it's running?"
					/varset Endmac TRUE
				}
			}
		}
	} else /if (${Option.Equal[off]}) {
		/if (${Plugin[${PluginName}].Name.Equal[${PluginName}]}) {
			/plugin ${PluginName} unload
			/delay 3s !${Plugin[${PluginName}].Equal[${PluginName}]}
			/if (!${Plugin[${PluginName}].Equal[${PluginName}]}) {
				/echo "The Plugin --> ${PluginName} has been unloaded."
			}
		}
	}
	/if (${Debugging}) /echo Sub CheckPlugin Exit
/return

Sub GetPullAbilityCommand
	/if (!${Me.Skill[${PullAbility}]} && !${Me.Book[${PullAbility}]} && !${Me.AltAbility[${PullAbility}]} && !${Me.CombatAbility[${PullAbility}]} && !${PullAbility.Equal[pet]} && !${FindItem[${PullAbility}].ID} && !${Select[${PullAbility},Ranged,Throwing,Archery,Bow]}) {
		/echo \ar${PullAbility} is not a Skill, Spell, AltAbility, or CombatAbility, or Item. Check your INI, using default Pulling.
		/declare PullCommand string outer
	} else {
		/if (${Me.Skill[${PullAbility}]}) {
			/if (${Debugging}) /echo \ayPullAbility:${PullAbility} is a skill
			/declare PullCommand string outer /doability ${PullAbility}
		} else /if (${Me.AltAbility[${PullAbility}]}) {
			/if (${Debugging}) /echo \ayPullAbility:${PullAbility} is an Alt Ability
			/declare PullCommand string outer /alt act ${Me.AltAbility[${PullAbility}].ID}
		} else /if (${Me.Book[${PullAbility}]}) {
			/if (${Debugging}) /echo \ayPullAbility:${PullAbility} is a spell.
			/declare PullCommand string outer /casting "${Spell[${PullAbility}].RankName}"
		} else /if (${Me.CombatAbility[${PullAbility}]}) {
			/if (${Debugging}) /echo \ayPullAbility:${PullAbility} is a disc.
			/declare PullCommand string outer /multiline ; ${If[${Me.CombatAbilityReady[${Spell[${PullAbility}].RankName}]},/disc ${PullAbility},]} ; ${If[${Me.CombatAbilityReady[${Spell[${PullAbility}].RankName}]},/doability "${Spell[${PullAbility}].RankName}",]}
		} else /if (${PullAbility.Equal[pet]}) {
			/if (${Debugging}) /echo \ayPullAbility: pet. 
			/declare PullCommand string outer /call PetPull
		} else /if (${FindItem[${PullAbility}].ID}) {
			/if (${Debugging}) /echo \ayPullAbility is an item.
			/declare PullCommand string outer /casting "${PullAbility}|Item"
		} else /if (${Select[${PullAbility},Ranged,Throwing,Archery,Bow]}) {
			/if (${Debugging}) /echo \ayPullAbility is ranged. 
			/declare PullCommand string outer /call RangedPull
			/echo \ayOverriding INI setting for PullAbilityRange
			/varset PullAbilityRange ${AmmoRange}
		}
	}
/return

Sub Declares
	/declare MobIgnore string outer FarmMobIgnored.ini
	/alias /showignored /echo \au${Ini[${MobIgnore},${Zone.ShortName},Ignored]}
	/declare Settings string outer FarmSettings_${Me}.ini
	/call CheckINI ${Settings} General Debugging bool FALSE
	/call CheckPlugin MQ2Melee
	/call CheckPlugin MQ2Nav
	/call CheckPlugin MQ2EQBC
	
	/declare Targets string outer NULL
	/declare myTargetID int outer 0
	/declare reportTarget timer outer 5s
	/declare startZone int outer ${Zone.ID}
	/declare courseCorrection timer outer 1s
	/declare SitDelay timer outer 5s
	
	/echo \ay${Settings} is the INI being used.
	/declare CampY int outer ${Me.Y}
	/declare CampX int outer ${Me.X}
	/declare CampZ int outer ${Me.Z}
	/declare DebugRepeatTimer timer outer 1s
	/call CheckINI ${Settings} General useLogOut bool FALSE
	/call CheckINI ${Settings} General assistMe bool TRUE
	/call CheckINI ${Settings} General UseEQBC bool FALSE
	/call CheckINI ${Settings} General UseMerc bool FALSE
	/call CheckINI ${Settings} Camp CampRadius int 60
	/call CheckINI ${Settings} Pull ZRadius int 500
	/call CheckINI ${Settings} Pull PullAbility string ReplaceMeWithYourSkill
	/call CheckINI ${Settings} Pull PullAbilityRange int 150
	/call CheckINI ${Settings} Pull PullRequiresLineOfSight bool TRUE
	/call CheckINI ${Settings} Health HealAt int  70
	/call CheckINI ${Settings} Health HealTill int 100
	/call CheckINI ${Settings} Endurance MedEndAt int 8
	/call CheckINI ${Settings} Endurance MedEndTill int 100
	/call CheckINI ${Settings} Mana MedAt int 30
	/call CheckINI ${Settings} Mana MedTill int 100
	/call CheckINI ${Settings} General CastDetrimental bool TRUE
	/call GetRangedInfo
	/call GetPullAbilityCommand

/return
